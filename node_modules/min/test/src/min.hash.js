import { should as Should } from 'chai'
import min from './min'

const should = Should()

describe('MinDB - Hash', () => {
  describe('hset', () => {
    it('should set the field in the hash on the key with the value', done => {
      min.hset('hashKey', 'foo', 'bar')
        .then(([ key, field, value ]) => {
          key.should.be.equal('hashKey')
          field.should.be.equal('foo')
          value.should.be.equal('bar')

          return min.del('hashKey')
        })
        .then(() => done())
        .catch(done)
    })
  })

  describe('hsetnx', () => {
    it('should set the field in the hash on the key if it was not exists', done => {
      min.hsetnx('hashKey', 'foo', 'bar')
        .then(() => min.hget('hashKey', 'foo'))
        .then(value => {
          value.should.be.equal('bar')

          return min.del('hashKey')
        })
        .then(() => done())
        .catch(done)
    })

    it('should return an error when the field of the hash was exists', done => {
      min.hset('hashKey', 'foo', 'bar')
        .then(() => min.hsetnx('hashKey', 'foo', 'bar'))
        .catch(err => {
          err.message.should.equal('The field of the hash is exists')

          done()
        })
    })
  })

  describe('hmset', () => {
    it('should set the fileds in the hash on the key with the values', done => {
      min.hmset('hashKey', {
        foo: 1,
        bar: 2
      })
        .then(() => min.hgetall('hashKey'))
        .then(hash => {
          hash.should.be.include.keys('foo')
          hash['foo'].should.be.equal(1)

          hash.should.be.include.keys('bar')
          hash['bar'].should.be.equal(2)

          return min.del('hashKey')
        })
        .then(() => done())
        .catch(done)
    })
  })

  describe('hexists', () => {
    it('should return the status of a field in a hash', done => {
      min.hset('hashKey', 'foo', 'bar')
        .then(() => min.hexists('hashKey', 'foo'))
        .then(exists => {
          exists.should.be.true

          done()
        })
        .catch(done)
    })
  })
})
